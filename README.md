# ИИ для пошаговой стратегии - Кейс 3

Команда для запуска
```bash
rm -rf build && cmake -S . -B build && cmake --build build && ./build/src/game_ai && ./build/part2/algorithm_selector

```
```bash
python3 -m http.server 8000
```

## Цель работы

Научиться выбирать алгоритмы поиска под конкретные задачи и понимать их сильные и слабые стороны на примере жадного поиска в глубину (Greedy DFS) в простой пошаговой стратегии.

## Описание кейса

Реализован упрощённый ИИ для игры на клеточном поле‑сетке. Карта задаётся символами:

- `.` — пустая клетка
- `#` — стена (проходимости нет)
- `P` — игрок
- `R` — ресурсы
- `E` — враг
- `B` — база

Алгоритм использует Greedy DFS: поиск в глубину, при котором переход в следующую клетку выбирается жадно — в первую очередь рассматриваются клетки с наилучшей эвристикой (меньшим значением).

Реализованы три уровня поведения ИИ:

### Уровень 1: поиск ресурсов (ближайшие цели)

Поиск пути от позиции игрока к ресурсу:

- цель — любая клетка `R`;
- эвристика — минимальное манхэттенское расстояние до любого ресурса.

Функция: `findResourcePath(const GameState &g)`.

### Уровень 2: атака врага (выбор цели)

1. Выбор врага с минимальным манхэттенским расстоянием до игрока.
2. Построение пути к выбранному врагу с помощью Greedy DFS.

Функции:
- `int chooseEnemyIndex(const GameState &g);`
- `std::vector<Pos> pathToEnemy(const GameState &g, int enemyIdx);`

### Уровень 3: захват базы (последовательность действий)

Построение пути к базе (`B`) через Greedy DFS с эвристикой по расстоянию до базы.

Функция: `std::vector<Pos> pathToBase(const GameState &g);`

---

## Структура проекта

```text
.
├── CMakeLists.txt
├── include
│   ├── game.h
│   ├── greedy_dfs.h
│   └── ai.h
├── src
│   ├── main.cpp
│   ├── game.cpp
│   ├── greedy_dfs.cpp
│   └── ai.cpp
└── build/            # каталог для сборки (создаётся автоматически)
